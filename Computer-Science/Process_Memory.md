<div align="center">
  <br />
  <h1>발표 제목</h1>
  <br />
</div>

## 목차

1. [**프로세스 메모리 구조**](#1)
2. [**메모리 분할**](#2)

<br />

<div id="1"></div>

## 프로세스 메모리

### 프로세스에 할당되는 메모리 영역

<img src = "https://user-images.githubusercontent.com/58917737/166688429-650a8a0f-52ab-4e06-a356-0258170ca183.png" width="150px">

프로세스가 시스템으로부터 할당받은 메모리의 구조는 다음과 같다.

낮은 주소부터 높은 주소까지 순서는 Code→Data→Heap→Stack 이다.

### 코드(code)

프로그램의 시작부터 종료까지 메모리가 계속 존재함.

사용자가 작성한 프로그램 함수들의 코드가 CPU에서 수행할 수 있는 기계어 명령 형태로 변환되어 저장되는 공간

컴파일(compile) 타임에 결정되고 중간에 코드를 바꿀 수 없게 **Read-Only** 로 되어있다.(변경하면, 오류 발생함)

코드 자체를 구성하는 메모리 영역으로 Hex파일이나 Bin파일 메모리임

### 데이터(data)

프로그램 시작과 동시에 할당되며, 종료 시 소멸됨.

전역 변수, 정적변수, 배열, 구조체 저장함

`BSS` 영역 + `Data(GVAR)` 영역

`BSS` 영역 - 초기화되지 않은 데이터

`Data(GVAR)` - 초기화된 데이터

**Why?**

- 초기화된 데이터는 초기 값을 저장해야되서 Data 영역의 Rom에 저장됨
  초기화되지 않은 데이터는 Ram에 저장됨.(Rom에 그것까지 저장하면 사이즈가 너무 커져야됨)

### 스택(stack)

함수 호출시 할당되고, 호출 완료 후에는 소멸됨

함수 호출과 관계되는 지역,매개 변수 저장

LIFO(Last In First Out) 구조

Compiletime의 크기 결정

### 힙(heap)

프로그래머에 의해 동적으로 메모리가 할당, 해제 됨

동적으로 생성된 데이터들은 모두 `포인터` 를 통해 접근함.

C에서는 `malloc()` `calloc()` 등의 함수로 메모리 크기 할당가능.

stack은 heap과 같은 공간을 공유한다. heap이 메모리의 낮은 주소부터 할당되면 stack은 높은 주소부터 할당된다. 그래서 각 영역이 상대 공간을 침범하는 `stack overflow` `heap overflow` 가 발생하게된다.

FIFO(First In FIrst Out)구조

<br />

<div id="2"></div>

## 메모리 분할

메모리 관리의 주된 작업은 처리기에 의해 실행될 프로세스를 주기억장치로 가져오는 것인데, 이 메모리를 관리하기 위한 기법들 중 ‘분할’이 있다.

### 고정 분할

고정된 경계를 가지는 메모리 영역으로 구분하는 것.

### 균등 분할

각 분할이 모두 같은 크기를 가지도록 하는 기법

한 프로세스의 크기가 분할의 크기보다 작거나 같으면, 사용 가느한 파티션 중 하나에 적재가 된다.
모든 파티션이 사용 중이며, 준비 또는 실행 상태의 프로세스가 없다면 운영체제는 어느 한 파티션의 프로세스를 스왑아웃 시키고, 다른 프로세스를 적재하여 프로세서가 쉬지 않도록 한다.

**문제점**

- 프로그램이 파티션보다 클때,
  - 오버레이를 사용하는 프로그램을 설계하여, 어느 순간에는 프로그램의 필요한 부분만 주기억장치에 있도록 해야한다.
- 적재되는 데이터가 파티션보다 작을때,
  - 파티션 내부 공간의 낭비가 발생→ **내부 단편화 발생**

### 동적 분할

- 파티션의 크기와 개수가 가변적이어서 정확히 요구된 크기 만큼의 메모리만 할당받음.
- 크기가 6M인 프로세스를 배치할 공간이 없으므로, 4M짜리 구멍이 남게되고, 기존 공간중 프로세스2를 스왑아웃하여 메모리를 확보한다. 이때, 프로세스2보다 프로세스 4가 더 작기때문에, 또다른 구멍이 생기게되는 문제가 생긴다.

<p align="center">
<img src = "https://user-images.githubusercontent.com/58917737/166688538-1cfd9532-1db7-47d7-b67c-bcbcf6e7d01e.png" width="155px">
<img src = "https://user-images.githubusercontent.com/58917737/166688571-116adc57-7eaa-4be4-ac96-be7d69057817.png" width="200px">
</p>

- 이런식으로 주기억장치에 작은 ‘구멍’들이 만들어진다. 시간이 지날수록 메모리 단편화가 점점 심해지며, 메모리 이용률또한 감소한다.
  메모리가 점차 사용할 수 없는 조각으로 변하는 현상을 외부 단편화 라고 한다.

**외부 단편화의 해결 방법 → 메모리 집약**

- 각 파티션이 연속적이게 되도록 인접하게 만들어 메모리의 모든 빈 공간이 하나의 블록이 되도록 하는 방법.
- 시간이 많이 걸리며, 처리기 시간을 낭비한다는 단점이 있다.
- 동적 재배치 기능이 필요하다. 즉, 프로그램의 메모리 참조가 아무런 영향을 받지 않고 프로그램을 주기억장치 내에서 이동시킬 수 있어야 한다.

<br />
