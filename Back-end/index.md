<div align="center">
  <br />
  <h1>Index (인덱스)_DB</h1>
  <br />
</div>

## 목차

1. [**Index란**](#1)
2. [**Clustered Index & Non-Clustered Index**](#2)
3. [**인덱스 설정 기준**](#3)

<br />

<div id="1"></div>

## Index란

책의 색인와 같은 역할

=> 책에서 원하는 부분을 빠르게 찾기 위한 역할

=> db에서 원하는 부분을 빠르게 찾기 위한 역할

> ex) '스프링5 프로그래밍 입문'이라는 책에서 '스프링부트'라는 단어를 찾는다고 할때, 맨뒤에 index페이지가 없다면, 책을 500페이지정도되는 이 책을 모두 살펴보아야 한다.
>
> 해당 책에서 인덱스는 책에서 **6쪽 정도의 분량**을 차지하고 있지만, 이를 통해서 빠르게 찾을 수 있다.

**인덱스 개념**

> 인덱스는 테이블이나 뷰와 관련된 **디스크상 구조**로서 **테이블이나 뷰의 행 검색 속도를 향상**시킵니다. 인덱스에는 테이블이나 뷰에 있는 하나 이상의 열로 작성되는 키가 포함됩니다. 이러한 키는 SQL Server 에서 키 값과 연결된 행을 빠르고 효율적으로 찾을 수 있는 **구조(b-트리)에 저장**됩니다.

- 인덱스는 select from where 절의 성능을 향상시킨다.
  - 왜 select from where절의 성능이 늦는가?
- insert,delete 에서는 성능을 저하시킬 수 있다.

<br />

<div id="2"></div>

## Clustered Index & Non-Clustered Index

- ndex로 생성되어 있는 컬럼을 기준으로 정렬되어 삽입이 된다.
  - 데이터 삽입, 수정, 삭제시 테이블의 데이터를 정렬함
- 테이블당 한개씩만 존재 할 수 있음
  - 가장 효율적일것 같은 컬럼을 Clustered Index로 지정하여 사용
- 범위 검색에 유리하다.
- 존재하는 pk사이에 insert할때, 굉장히 시간이 오래 걸릴 수 있음.
  - **Auto_Increment**
- 어떤경우에 사용?
  - 테이블 데이터가 자주 업데이트 되지 않는 경우
  - 항상 정렬된 방식으로 데이터를 반환해야 하는 경우
    - 테이블이 정렬되어 있기 때문에 order by절을 활용하여 모든 테이블 데이터를 스캔하지 않고 원하는 데이터를 조회할 수 있다.
  - 읽기 작업이 월등히 많은 경우

| level | 이름   |
| ----- | ------ |
| 2     | 김다인 |
| 4     | 박정환 |
| 5     | 왕수련 |

'이아영' 데이터가 삽입될때,'김다인', '박정환','왕수련'데이터를 모두 밀어야 한다.(하나가 삽입될때, 그 뒤로 모든 데이터를 밀어야 하기 때문에, 시간 소모가 크다.)

| level | 이름   |
| ----- | ------ |
| 1     | 이아영 |
| 2     | 김다인 |
| 4     | 박정환 |
| 5     | 왕수련 |

#### -> Clustered Index 방식

> Clustered Index는 루트 페이지와 리프 페이지로 구성되어 있으며, 리프페이지는 데이터 페이지를 말한다.
>
> Clustered Index는 물리적으로 정렬되어 있어, 검색 속도가 Non-Clustered Index보다 더 빠르지만, 입력/수정/삭제 시 정렬하여, 이때의 속도는 더 느리다.

### Non-Clustered Index

- 순서와 상관이 없이 저장되어 있음
- 추가 저장공간이 필요하다(테이블 데이터와 함께 테이블에 저장되는 것이 아님)
- INSERT시 추가 작업이 필요(인덱스 생성)

| level | Address |
| ----- | ------- |
| 4     | 120     |
| 2     | 150     |
| 1     | 483     |
| 5     | 293     |

| Address | Name   |
| ------- | ------ |
| 120     | 박정환 |
| 150     | 김다인 |
| 483     | 이아영 |
| 293     | 왕수련 |

물리적으로 데이터를 배열하지 않은상태로 데이터 페이지가 구성된다.

select 쿼리에서 성능이 좋다.

<br />

<div id="3"></div>

## 인덱스 설정 기준

한 테이블당 보통 3-5개 적당하다. 후보 컬럼의 특징들을 잘 파악하는 세가지 기준으로, 인덱스를 설정

- **cardinality** \_ 컬럼에 사용되는 값의 다양성 정도, 즉 중복 수치를 나타내는 지표

  - 중복이 많은 데이터는 카디널리티가 낮다

  - 중복이 적은 데이터는 카디널리티가 높다.

- **선택도**

  - 데이터에서 특정 값을 얼마나 잘 선택할 수 있는지에 대한 지표

  - 5~10% 정도가 적당

  - 선택도가 낮을 수록 인덱스에 좋은 컬럼

  - 선택도 계산법

    - 선택도 = 컬럼의 특정 값의 row수/ 테이블의 총 row 수 x100

      ​ = 컬럼의 값들의 평균 row 수/ 테이블의 총 row수 x100

    - 문제)

      - 10개의 rows를 가지는 스터디 테이블에 학번, 이름, 성별 칼럼이 있다. 이때, 학번은 고유하고, 이름은 2명씩 같고, 성별은 5:5비율이다.
        1. '학번'의 선택도 (1/10)\*100
        2. '이름'의 선택도 (2/10)\*100
        3. '성별'의 선택도 (5/10)\*100

- **활용도**

  - 해당 컬럼이 실제 작업에 얼마나 활용되는지에 대한 값
  - 활용도가 높을 수록 좋음

인덱스도 메모리의 일부이므로, 필요 없는 항목은 삭제하는게 좋고, 그래서 중복도가 없을 수록 좋은 것임

| 기준       | 정도           |
| ---------- | -------------- |
| 카디널리티 | 높을수록 적합  |
| 선택도     | 낮을 수록 적합 |
| 활용도     | 높을 수록 적합 |

### 인덱스를 생성할때 고려해야 할 사항

1. 테이블 전체 열의 15% 이하의 데이터를 조회할떄 인덱스를 생성한다.
2. 테이블 건수가 적다면(코드성 테이블)굳이 인덱스를 만들 필요가 없다.
3. 데이터의 유일성 정도가 좋거나 범위가 넓은 값을 가진 칼럼을 인덱스로 만드는 것이 좋다.
4. NULL이 많이 포함된 컬럼은 인덱스 컬럼으로 만들기 적당하지 않다.
5. 결합 인덱스를 만들때는, 컬럼의 순서가 중요하다.
   - 보통 자주 사용하는 컬럼을 앞에 둔다.
6. 테이블에 만들 수 있는 인덱스 수의 제한은 없으나, 너무 많이 만들면 오히려 성능 부하가 발생한다.
   - INSERT,DELETE,UPDATE시에 부하가 발생하여 배보다 배꼽이 더큰 결과가 생긴다.

> 참고자료
>
> - [10분 테코톡] 안돌의 INDEX https://www.youtube.com/watch?v=NkZ6r6z2pBg
> - [10분 테코톡] 레베카의 인덱스 https://www.youtube.com/watch?v=9ZXIoh9PtwY
> - 오라클 SQL과 PL/SQL을 다루는 기술
> - https://velog.io/@gillog/SQL-Clustered-Index-Non-Clustered-Index
> - https://gwang920.github.io/database/clusterednonclustered/
